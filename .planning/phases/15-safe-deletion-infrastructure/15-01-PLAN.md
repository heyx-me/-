<plan>
  <id>15-01</id>
  <name>Implement Safe Deletion Infrastructure</name>
  <description>Enable "Hydrate & Destroy" pattern by updating UI to handle message deletions and implementing the logic in BankingContext and Nanie App.</description>
  <frontmatter>
    <wave>1</wave>
    <depends_on>none</depends_on>
    <files_modified>app.jsx, rafi/contexts/BankingContext.jsx, nanie/app.jsx</files_modified>
    <autonomous>true</autonomous>
  </frontmatter>
  <tasks>
    <task>
      <id>1</id>
      <title>Update Chat Interface for Deletion</title>
      <file>app.jsx</file>
      <instruction>
        1.  In `ChatInterface` component (inside `app.jsx`):
            -   Add a `postgres_changes` listener for the `DELETE` event on the `messages` table.
            -   When a DELETE event is received, remove the corresponding message from the `messages` state and `messageCache`.
            -   This ensures that when a message is deleted by the backend/context, it disappears from the UI immediately.
        2.  Update `shouldHideMessage` function:
            -   Check `localStorage.getItem('debug_mode')`.
            -   If `'true'`, return `false` (do not hide anything), allowing developers to see all messages.
      </instruction>
    </task>
    <task>
      <id>2</id>
      <title>Implement Hydrate & Destroy in BankingContext</title>
      <file>rafi/contexts/BankingContext.jsx</file>
      <instruction>
        1.  In `handleIncomingMessage`:
            -   Locate the `DATA` case.
            -   After `setData` or `handlePaginationMerge` is called (successful hydration):
                -   Check if `localStorage.getItem('debug_mode') === 'true'`.
                -   If NOT in debug mode, call `supabase.from('messages').delete().eq('id', msg.id)`.
            -   Locate the `LOGIN_SUCCESS` case.
                -   Similarly, after processing, trigger deletion of the message if not in debug mode.
            -   Ensure this logic is robust (wrap in try/catch) to prevent app crash if deletion fails.
      </instruction>
    </task>
    <task>
      <id>3</id>
      <title>Implement Hydrate & Destroy in Nanie App</title>
      <file>nanie/app.jsx</file>
      <instruction>
        1.  In `fetchStatus` (inside `AppContent`):
            -   Locate the `postgres_changes` subscription.
            -   Inside the `INSERT` handler, after successfully parsing and processing `DATA` messages (both `events` and `groups` types):
                -   Check `localStorage.getItem('debug_mode') === 'true'`.
                -   If NOT in debug mode, trigger deletion of the message: `supabase.from('messages').delete().eq('id', payload.new.id)`.
            -   Ensure this is done *after* state updates (`setEvents` or `setAvailableGroups`).
      </instruction>
    </task>
  </tasks>
  <verification>
    <manual>
      1.  **Debug Mode Test**:
          -   Open app in browser.
          -   Run `localStorage.setItem('debug_mode', 'true')`.
          -   Trigger data sync in Rafi (Refresh) and Nanie.
          -   Verify `DATA` messages persist in chat.
      2.  **Deletion Test**:
          -   Run `localStorage.removeItem('debug_mode')`.
          -   Trigger data sync.
          -   Verify `DATA` messages appear briefly and then DISAPPEAR.
          -   Verify data (balances/events) remains visible in the UI.
    </manual>
    <automated>
      - None (Requires E2E with full backend).
    </automated>
  </verification>
  <must_haves>
    - DELETE event listener in app.jsx.
    - debug_mode toggle logic.
    - Deletion call in BankingContext and Nanie App after state update.
  </must_haves>
</plan>